import os
import numpy as np
from collections import defaultdict
from matplotlib.image import imread
from skimage.transform import resize
from scipy.spatial.distance import cdist
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, pairwise_kernels
from sklearn.model_selection import LeaveOneOut

def load(yale_path, shape=(28, 28)):
    X, y = [], []
    for fname in sorted(os.listdir(yale_path)):
        if fname.startswith("subject"):
            person_id = int(fname[7:9])
            img = imread(os.path.join(yale_path, fname))
            img = resize(img, shape, anti_aliasing=True).astype(np.float32)
            X.append(img.flatten())
            y.append(person_id)
    return np.array(X), np.array(y)

def rbf(X, gamma):
    return np.exp(-gamma * cdist(X, X, metric='sqeuclidean'))

def polynomial(X, degree, alpha=1.0, r=1.0):
    return (alpha * (X @ X.T) + r) ** degree

def center_kernel(K):
    n = K.shape[0]
    ones = np.ones((n, n)) / n
    return K - ones @ K - K @ ones + ones @ K @ ones

def kernel_pca(X, kernel, degree=None, gamma=None, alpha=1.0, r=1.0, variance_threshold=0.90):
    if kernel == 'rbf':
        K = rbf(X, gamma)
    elif kernel == 'polynomial':
        K = polynomial(X, degree=degree, alpha=alpha, r=r)
    else:
        None

    K_centered = center_kernel(K)
    eigenvalues, eigenvectors = np.linalg.eigh(K_centered)
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues, eigenvectors = eigenvalues[idx], eigenvectors[:, idx]

    mask = eigenvalues > 1e-10
    eigenvalues, eigenvectors = eigenvalues[mask], eigenvectors[:, mask]

    var_ratio = eigenvalues / np.sum(eigenvalues)
    cumulative = np.cumsum(var_ratio)
    n_components = np.searchsorted(cumulative, variance_threshold) + 1
    top_eigenvalues = eigenvalues[:n_components]
    top_eigenvectors = eigenvectors[:, :n_components]
    norm_eigenvectors = top_eigenvectors / np.sqrt(top_eigenvalues)

    return K_centered, norm_eigenvectors, top_eigenvalues

def project(train, test, kernel, degree=None, gamma=None, eigenvectors=None, alpha=1.0, r=1.0):
    all_data = np.vstack([train, test.reshape(1, -1)])

    params = {}
    if kernel == 'rbf':
        params['gamma'] = gamma
    elif kernel == 'polynomial':
        params['gamma'] = alpha
        params['degree'] = degree
        params['coef0'] = r

    K_full = pairwise_kernels(all_data, metric=kernel, **params)
    K_mean_row = np.mean(K_full, axis=1, keepdims=True)
    K_mean_col = np.mean(K_full, axis=0, keepdims=True)
    K_mean_total = np.mean(K_full)
    K_full_centered = K_full - K_mean_row - K_mean_col + K_mean_total
    K_test_centered = K_full_centered[-1, :-1]

    return K_test_centered @ eigenvectors

def main(yale_path, kernel='polynomial', degree=2, alpha=1.0, r=1.0, gamma=0.00153):
    images, labels = load(yale_path)
    images = StandardScaler().fit_transform(images)

    loo = LeaveOneOut()
    true_svm, pred_svm = [], []
    true_knn = []
    knn_pred = defaultdict(list)

    for train, test in loo.split(images):
        train_img, test_img = images[train], images[test]
        train_label, test_label = labels[train], labels[test]

        K_train, eigvectors, _ = kernel_pca(
            train_img, kernel=kernel, degree=degree, gamma=gamma,
            alpha=alpha, r=r, variance_threshold=0.95
        )
        train_proj = K_train @ eigvectors

        test_proj = np.vstack([
            project(train_img, images[i], kernel=kernel, degree=degree, gamma=gamma, eigenvectors=eigvectors, alpha=alpha, r=r)
            for i in test
        ])

        clf = SVC(kernel="linear")
        clf.fit(train_proj, train_label)
        svm_predictions = clf.predict(test_proj)

        true_svm.append(test_label[0])
        pred_svm.append(svm_predictions[0])

        true_knn.append(test_label[0])
        for k in range(1, 11):
            knn = KNeighborsClassifier(n_neighbors=k)
            knn.fit(train_proj, train_label)
            pred_knn = knn.predict(test_proj)
            knn_pred[k].append(pred_knn[0])

    acc_svm = accuracy_score(true_svm, pred_svm)
    print(f"   SVM: {acc_svm:.3f}")

main("/path/to/your/data")
